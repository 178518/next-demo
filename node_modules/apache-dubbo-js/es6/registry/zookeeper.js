"use strict";
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const ip_1 = __importDefault(require("ip"));
const node_zookeeper_client_1 = __importStar(require("node-zookeeper-client"));
const querystring_1 = __importDefault(require("querystring"));
const dubbo_url_1 = __importDefault(require("../dubbo-url"));
const err_1 = require("../err");
const go_1 = require("../go");
const util_1 = require("../util");
const registry_1 = __importDefault(require("./registry"));
const log = debug_1.default('dubbo:zookeeper');
const ipAddress = ip_1.default.address();
const CHECK_TIME = 30 * 1000;
class ZkRegistry extends registry_1.default {
    constructor(props) {
        super(props);
        //========================private method==========================
        this._init = (err) => __awaiter(this, void 0, void 0, function* () {
            //zookeeper occur error
            if (err) {
                log(err);
                util_1.traceErr(err);
                this._subscriber.onError(err);
                return;
            }
            //zookeeper connected（may be occur many times）
            const { zkRoot, application: { name }, interfaces, } = this._props;
            //获取所有provider
            for (let inf of interfaces) {
                //当前接口在zookeeper中的路径
                const dubboServicePath = `/${zkRoot}/${inf}/providers`;
                //当前接口路径下的dubbo url
                const { res: dubboServiceUrls, err } = yield go_1.go(this._getDubboServiceUrls(dubboServicePath, inf));
                // 重连进入init后不能清空已有provider, 会导致运行中的请求找到, 报no agents错误
                // 或者zk出现出错了, 无法获取provider, 那么之前获取的还能继续使用
                if (err) {
                    log(`getChildren ${dubboServicePath} error ${err}`);
                    util_1.traceErr(err);
                    //If an error occurs, continue
                    continue;
                }
                // set dubbo interface meta info
                this._dubboServiceUrlMap.set(inf, dubboServiceUrls.map(dubbo_url_1.default.from));
                //写入consumer信息
                this._createConsumer({
                    name: name,
                    dubboInterface: inf,
                }).then(() => log('create Consumer finish'));
            }
            if (util_1.isDevEnv) {
                log('agentAddrSet: %O', this._allAgentAddrSet);
                log('dubboServiceUrl:|> %O', this._dubboServiceUrlMap);
            }
            this._subscriber.onData(this._allAgentAddrSet);
        });
        //========================zookeeper helper=========================
        /**
         * connect zookeeper
         */
        this._connect = (callback) => {
            const { url: register, zkAuthInfo } = this._props;
            //debug log
            log(`connecting zkserver ${register}`);
            // remove all listeners, avoid memory leak
            if (this._client) {
                this._client.removeAllListeners();
            }
            //connect
            this._client = node_zookeeper_client_1.default.createClient(register, {
                retries: 10,
            });
            // add auth info
            if (zkAuthInfo && zkAuthInfo.scheme && zkAuthInfo.auth) {
                this._client.addAuthInfo(zkAuthInfo.scheme, Buffer.from(zkAuthInfo.auth));
            }
            //手动做一个超时检测
            //node-zookeeper-client启动时候有个bug，当连不上zk时会无限重连
            const timeId = setTimeout(() => {
                log(`Could not connect zk ${register}， time out`);
                this._client.close();
                callback(new err_1.ZookeeperTimeoutError(`ZooKeeper was connected ${register} time out. `));
            }, 30 * 1000);
            this._client.once('connected', () => {
                log(`connected to zkserver ${register}`);
                clearTimeout(timeId);
                callback(null);
                util_1.msg.emit('sys:ready');
                this._monitor();
            });
            //the connection between client and server is dropped.
            this._client.once('disconnected', () => {
                log(`zk ${register} had disconnected`);
                clearTimeout(timeId);
                util_1.traceErr(new err_1.ZookeeperDisconnectedError(`ZooKeeper was disconnected. current state is ${this._client.getState()} `));
                this._reconnect();
            });
            this._client.once('expired', () => {
                clearTimeout(timeId);
                log(`zk ${register} had session expired`);
                util_1.traceErr(new err_1.ZookeeperExpiredError(`Zookeeper was session Expired Error current state ${this._client.getState()}`));
                this._client.close();
            });
            //connect
            this._client.connect();
        };
        this._getChildren = (path, watch) => {
            return new Promise((resolve, reject) => {
                this._client.getChildren(path, watch, (err, children, stat) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve({
                        children,
                        stat,
                    });
                });
            });
        };
        this._create = (path, mode) => {
            return new Promise((resolve, rejec) => {
                this._client.create(path, mode, (err, path) => {
                    if (err) {
                        rejec(err);
                        return;
                    }
                    resolve(path);
                });
            });
        };
        this._exists = (path) => {
            return new Promise((resolve, reject) => {
                this._client.exists(path, (err, stat) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(stat);
                });
            });
        };
        log(`new:|> %O`, props);
        //默认dubbo
        this._props.zkRoot = this._props.zkRoot || 'dubbo';
        //初始化zookeeper的client
        this._connect(this._init);
    }
    /**
     * 重连
     */
    _reconnect() {
        clearInterval(this._checkTimer);
        if (this._client) {
            this._client.close();
        }
        this._connect(this._init);
    }
    /**
     * 由于zk自己的监测机制不明确, 改为自主检测
     */
    _monitor() {
        clearInterval(this._checkTimer);
        this._checkTimer = setInterval(() => {
            const state = this._client.getState();
            switch (state) {
                case node_zookeeper_client_1.State.EXPIRED:
                case node_zookeeper_client_1.State.DISCONNECTED:
                    log(`checker is error, state is ${state}, need reconnect`);
                    this._reconnect();
                    break;
                default:
                    log(`checker is ok, state is ${state}`);
            }
        }, CHECK_TIME);
    }
    /**
     * 获取所有的负载列表，通过agentAddrMap聚合出来
     * 这样有点Reactive的感觉，不需要考虑当中增加删除的动作
     */
    get _allAgentAddrSet() {
        const agentSet = new Set();
        for (let urlList of this._dubboServiceUrlMap.values()) {
            for (let url of urlList) {
                agentSet.add(url.host + ':' + url.port);
            }
        }
        return agentSet;
    }
    /**
     * 获取所有的provider列表
     * @param {string} dubboServicePath
     * @param dubboInterface
     * @returns {Promise<Array<string>>}
     * @private
     */
    _getDubboServiceUrls(dubboServicePath, dubboInterface) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._getChildren(dubboServicePath, this._watchWrap(dubboServicePath, dubboInterface)).then(res => {
                return (res.children || [])
                    .map(child => decodeURIComponent(child))
                    .filter(child => child.startsWith('dubbo://'));
            });
        });
    }
    _watchWrap(dubboServicePath, dubboInterface) {
        return (e) => __awaiter(this, void 0, void 0, function* () {
            log(`trigger watch ${e}`);
            //会有概率性的查询节点为空，可以延时一些时间
            // await delay(2000);
            const { res: dubboServiceUrls, err } = yield go_1.go(this._getDubboServiceUrls(dubboServicePath, dubboInterface));
            // when getChildren had occur error
            if (err) {
                log(`getChildren ${dubboServicePath} error ${err}`);
                util_1.traceErr(err);
                return;
            }
            const urls = dubboServiceUrls.map(serviceUrl => dubbo_url_1.default.from(serviceUrl));
            if (urls.length === 0) {
                util_1.traceErr(new Error(`trigger watch ${e} agentList is empty`));
                return;
            }
            //clear current dubbo interface
            this._dubboServiceUrlMap.set(dubboInterface, urls);
            if (util_1.isDevEnv) {
                log('agentSet:|> %O', this._allAgentAddrSet);
                log('update dubboInterface %s providerList %O', dubboInterface, this._dubboServiceUrlMap.get(dubboInterface));
            }
            this._subscriber.onData(this._allAgentAddrSet);
        });
    }
    /**
     * com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry
     */
    _createConsumer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let { name, dubboInterface } = params;
            const dubboSetting = this._props.dubboSetting.getDubboSetting(dubboInterface);
            if (!dubboSetting) {
                throw new Error(`Could not find group, version for ${dubboInterface} please check your dubbo setting`);
            }
            const queryParams = {
                interface: dubboInterface,
                application: name,
                category: 'consumers',
                method: '',
                revision: '',
                version: dubboSetting.version,
                group: dubboSetting.group,
                side: 'consumer',
                check: 'false',
            };
            //create root comsumer
            const consumerRoot = `/${this._props.zkRoot}/${dubboInterface}/consumers`;
            const err = yield this._createRootConsumer(consumerRoot);
            if (err) {
                log('create root consumer: error %o', err);
                return;
            }
            //create comsumer
            const consumerUrl = consumerRoot +
                '/' +
                encodeURIComponent(`consumer://${ipAddress}/${dubboInterface}?${querystring_1.default.stringify(queryParams)}`);
            const exist = yield go_1.go(this._exists(consumerUrl));
            if (exist.err) {
                log(`check consumer url: ${decodeURIComponent(consumerUrl)} failed`);
                return;
            }
            if (exist.res) {
                log(`check consumer url: ${decodeURIComponent(consumerUrl)} was existed.`);
                return;
            }
            const create = yield go_1.go(this._create(consumerUrl, node_zookeeper_client_1.default.CreateMode.EPHEMERAL));
            if (create.err) {
                log(`check consumer url: ${decodeURIComponent(consumerUrl)}创建consumer失败 %o`, create.err);
                return;
            }
            log(`create successfully consumer url: ${decodeURIComponent(consumerUrl)}`);
        });
    }
    _createRootConsumer(consumer) {
        return __awaiter(this, void 0, void 0, function* () {
            let { res, err } = yield go_1.go(this._exists(consumer));
            //check error
            if (err) {
                return err;
            }
            // current consumer root path was existed.
            if (res) {
                return null;
            }
            //create current consumer path
            ({ err } = yield go_1.go(this._create(consumer, node_zookeeper_client_1.default.CreateMode.PERSISTENT)));
            if (err) {
                return err;
            }
            log('create root comsumer %s successfull', consumer);
        });
    }
}
exports.ZkRegistry = ZkRegistry;
function zk(props) {
    return (dubboProps) => new ZkRegistry(Object.assign({}, props, dubboProps));
}
exports.default = zk;

/// <reference types="node" />
import Registry from './registry/registry';
import { Setting } from './setting';
export declare type THostPort = string;
export declare type TAgentAddr = string;
export declare type TDubboInterface = string;
/**
 * dubbo对象透传给registry的类型
 */
export interface IDubboRegistryProps {
    application?: {
        name: string;
    };
    interfaces: Array<string>;
    dubboSetting: Setting;
}
export interface IRegistrySubscriber {
    onData: (agentSet: Set<THostPort>) => void;
    onError: (err: Error) => void;
}
export interface IObservable<T> {
    subscribe(subscriber: T): this;
}
export declare type TDecodeBuffSubscriber = (data: Buffer) => void;
export interface ITrace {
    type: 'INFO' | 'ERR';
    msg: string | Error;
    pid?: string;
    host?: string;
    time?: string;
}
export interface IDubboSubscriber {
    onTrace: (msg: ITrace) => void;
}
export interface ISocketSubscriber {
    onConnect: Function;
    onData: Function;
    onClose: Function;
}
export interface ISocketAgentProps {
    agentHostList: Set<string>;
}
export interface IDirectlyDubboProps {
    dubboAddress: string;
    dubboVersion: string;
    dubboInvokeTimeout?: number;
}
export interface IInvokeParam {
    dubboInterface: string;
    methods: {
        [methodName: string]: Function;
    };
    group?: string;
    version?: string;
    timeout?: number;
}
export interface IDubboProps {
    application: {
        name: string;
    };
    register: ((props: IDubboRegistryProps) => Registry) | string;
    service: Object;
    isSupportedDubbox?: boolean;
    dubboInvokeTimeout?: number;
    dubboSocketPool?: number;
    dubboSetting: Setting;
}
export declare type TDubboService<T> = {
    [k in keyof T]: T[k] extends ((dubbo: any) => infer R) ? R : any;
};
export interface IDubboResult<T> {
    err: Error;
    res: T;
}
export declare type TDubboCallResult<T> = Promise<IDubboResult<T>>;
export interface IDubboProvider {
    dubboInterface: string;
    version?: string;
    timeout?: number;
    group?: string;
    methods: {
        [methodName: string]: Function;
    };
}
export declare type IZKAuthSchemes = 'world' | 'ip' | 'host' | 'auth' | 'digest';
export interface IZKAuthInfo {
    scheme: IZKAuthSchemes;
    auth: string;
}
export interface IZkClientProps {
    zkAuthInfo?: IZKAuthInfo;
    zkRoot?: string;
    url: string;
}
export interface IProviderProps {
    host: string;
    port: number;
    path: string;
    dubboVersion: string;
    version: string;
    group: string;
    timeout: number;
}
export declare type TRequestId = number;
export interface IDubboResponse<T> {
    requestId: number;
    err: Error | null;
    res: T | null;
    attachments: Object;
}
export interface IHessianType {
    $class: string;
    $: any;
}
export declare type Middleware<T> = (context: T, next: () => Promise<any>) => any;
export interface IContextRequestParam {
    requestId: number;
    dubboVersion: string;
    dubboInterface: string;
    path: string;
    methodName: string;
    methodArgs: Array<IHessianType>;
    version: string;
    timeout: number;
    group: string;
}
export interface IQueryObj {
    application: string;
    dubbo: string;
    interface: string;
    path: string;
    methods: string;
    version: string;
    group: string;
}
export declare type TQueueObserver = Function;
export interface ICreateConsumerParam {
    name: string;
    dubboInterface: string;
}
